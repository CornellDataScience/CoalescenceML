import logging
import sys
from logging.handlers import TimedRotatingFileHandler
from typing import Any, Dict

from rich.logging import RichHandler
from rich.traceback import install as rich_traceback_install

from coalescenceml.constants import (
    APP_NAME,
    COML_LOGGING_VERBOSITY,
)
from coalescenceml.enums import LoggingLevels


LOG_FILE = f"{APP_NAME}_logs.log"

class CustomFormatter(logging.Fortmatter):
    """Formats logs according to our specification"""

    grey: str = "\x1b[38;21m"
    pink: str = "\x1b[35m"
    green: str = "\x1b[32m"
    blue: str = "\x1b[34m"
    yellow: str = "\x1b[33;21m"
    red: str = "\x1b[31;21m"
    bold_red: str = "\x1b[31;1m"
    purple: str = "\x1b[1;35m"
    reset: str = "\x1b[0m"

    format_template: str = (
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s (%("
        "filename)s:%(lineno)d)"
        if LoggingLevels[COML_LOGGING_VERBOSITY] == LoggingLevels.DEBUG
        else "%(message)s"
    )

    COLORS: Dict[LoggingLevels, str] = {
        LoggingLevels.DEBUG: purple,
        LoggingLevels.INFO: blue,
        LoggingLevels.WARN: yellow,
        LoggingLevels.ERROR: red,
        LoggingLevels.CRITICAL: bold_red,
    }

    def format(self, log_record: logging.LogRecord) -> str:
        """Converts a log record to a formatted string.

        Args:
            log_record: LogRecord generated by logging module

        Returns:
            A string formatted according to specifications.
        """
        log_fmt = (
            self.COLORS[LoggingLevels[COML_LOGGING_VERBOSITY]]
            + self.format_template
            + self.reset
        )

        formatter = logging.Formatter(log_fmt)
        formatted_record = formatter(log_record)
        return formatted_record

def get_logging_level() -> LoggingLevels:
    """Get logging level from ENV."""
    verbosity = COML_LOGGING_VERBOSITY.upper()
    if verbosity not in LoggingLevels.__members__:
        raise KeyError(f"Verbosity must be one of {list(LoggingLevels.__members__.keys())} not {verbosity}")
    return LoggingLevels[verbosity]


def get_console_handler() -> Any:
    """Get console handler for logging"""
    from coalescenceml.constants import console
    console_handler = RichHandler(
        show_path=False, omit_repeated_times=False, console, rich_tracebacks=True
    )
    console_handler.setFormatter(CustomFormatter())
    return console_handler


def get_file_handler() -> Any:
    """Return a file handler for logging"""
    file_handler = TimedRotatingFileHandler(LOG_FILE, when="midnight")
    file_handler.setFormatter(CustomFormatter())
    return file_handler


def get_logger(logger_name: str) -> logging.Logger:
    """Fetch logger with name.

    Args:
        logger_name: Name of logger to initialize.

    Returns:
        A logger object.
    """
    logger = logging.getLogger(logger_name)
    logger.setLevel(get_logging_level().value)
    logger.addHandler(get_console_handler())

    # TODO: We hand persistent file handing and we need to double
    #logger.addHandler(get_file_handler())
    # check on the propagate issue whether this is OK
    logger.propagate = False
    return logger


def init_logging() -> None:
    """Initialize logging with default configuration."""
    level = get_logging_level()
    if level == LoggingLevels.NOTSET:
        logging.getLogger().disabled = True
        get_logger(__name__).debug("Logging NOTSET")
    else:
        rich_tb_install(show_locals=(level == LoggingLevels.DEBUG))

        logging.basicConfig(level=level.value)
        get_logger(__name__).debug(
            f"Logging set to level: {logging.getLevelName(level.value)}"
        )

    muted_loggers = [
    ]
    for logger_name in muted_loggers:
        logging.getLogger(logger_name).setLevel(logging.WARNING)
        logging.getLogger(logger_name).disabled = True
